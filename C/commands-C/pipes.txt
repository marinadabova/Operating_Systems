Помощни команди:
pipes

pipe(7)

Pipes and FIFOs (also known as named pipes) осигуряват еднопосочно междупроцесен комуникационен канал. 
pipe-a има read end и write end
Данните записани върху края за писане на пайпа могат да бъдат прочетени от края за четене на пайпа

Пайпа се създава, използвайки pipe(2) 
То създава нов пайп и връща два файлови дескриптора
-единия сочи към край за четене (to the read end of the pipe)
-другия сочи към края за писане (to the write end)
Пайпа може да се използва за създаване на канал за комуникация между свързани процеси


pipe(2) 
int pipe(int pipefd[2]);


FIFO (съкратено от First In First Out) има име във файловата система(създадено с помощта на mkfifo(3)) 
и се отваря с помощта на open(2). 
Всеки процес може да отвори FIFO, ако  пермишъните на файла го позволяват.

-краят за четене се отваря с помощта на флага O_RDONLY;
-краят на записа се отваря с помощта на флага O_WRONLY. 


mkfifo(3) 
int mkfifo(const char * pathname, mode_t mode);


Единствената разлика между пайпа и фифо е начина по който се създават и се отварят

Ако процес се опита да чете от празен пайп, read(2) ще блокира, докато данните са налични. 
Ако процес се опита да пише на пълна тръба, write(2) блокира, докато има достатъчно данни, прочетени от пайпа, за да може записът да завърши. не-
      
Неблокиращи I/O е възможно чрез използване на fcntl(2) F_SETFL операция за активирайте флага за състояние на отворен файл O_NONBLOCK.


Комуникационният канал, осигурен от тръба, е поток от байтове: там няма концепция за граници на съобщенията.

Ако всички файлови дескриптори, отнасящи се до края за запис на тръба,са затворени, тогава опит за четене (2) от тръбата ще види end-of-file  (read(2) will return 0). 
Ако всички файлови дескриптори, отнасящи се до края за четене на тръбата са затворени, тогава write(2) ще предизвикват генериране на сигнал SIGPIPE за процеса на повикване. 
Ако процесът на извикване игнорира този сигнал, тогава write(2) е неуспешен с грешка EPIPE.
Приложение, което използва pipe(2) и fork(2) трябва да използва подходящи извиквания close(2), за да затвори ненужния дубликат файлови дескриптори; това гарантира, че края на файла и SIGPIPE/EPIPE се доставят, когато е подходящо.

Не е възможно да се приложи lseek(2) към pipe.

Pipe capacity
pipe-a има лимитиран капацитет
Ако тръбата е пълна, тогава write(2) ще блокира или ще се провали, в зависимост от това дали флагът O_NONBLOCK е зададен



pipe(2) 
int pipe(int pipefd[2]);
Създава pipe
#include <unistd.h>

int pipe2(int pipefd[2], int flags);
pipe() създава тръба, еднопосочен канал за данни, който може да бъде
        използвани за междупроцесна комуникация.
Масивът pipefd се използва да върне два файлови дескриптора, отнасящи се до краищата на тръбата.
pipefd[0] се отнася за четения край на канала. 
pipefd[1] се отнася за записващият край на тръбата.
 Данни, записани в края за запис на тръбата се буферира от ядрото, докато не бъде прочетена от края за четене на тръбата.

Ако флаговете са 0,то тогава pipe2() е същото като pipe(). 
Следните стойностите могат да бъдат побитово ИЛИ във флагове, за да се получи различно поведение:
O_CLOEXEC
O_DIRECT
O_NONBLOCK
O_NOTIFICATION_PIPE

RETURN VALUE
При успех връща 0
При грешка -1




fifo - first-in first-out special file, named pipe
Специални FIFO файлове могат да бъдат създадени от mkfifo(3) и са обозначени от ls -l с файлов тип 'p'.


Специален FIFO файл (наименуван pipe) е подобен на pipe, с изключение на това, че достъпен като част от файловата система. 
Може да се отваря от множество процеси за четене или писане. 
Когато процесите обменят данни чрез FIFO, ядрото предава всички данни вътрешно, без да ги записва във файловата система.
По този начин специалният файл FIFO няма съдържание във файловата система;
записът във файловата система служи просто като отправна точка, така че процесите да имат достъп до тръбата, използвайки име във файловата система.

Ядрото поддържа точно един pipe обект за всеки специален FIFO файл, който е отворен от поне един процес. 
FIFO трябва да бъде отварян от двата края (четене и запис), преди данните да могат да бъдат предадени.

Процесът може да отвори FIFO в неблокиращ режим.
  

mkfifo(3) 
int mkfifo(const char * pathname, mode_t mode);
mkfifo, mkfifoat - make a FIFO special file (a named pipe)

#include <sys/types.h>
#include <sys/stat.h>

int mkfifo(const char *pathname, mode_t mode);

mkfifo() създава FIFO специален файл с име pathname. mode специфицира пермишъните на FIFO. 

RETURN VALUE
При успех връща 0
При грешка -1



dup(2) 
int dup(int oldfd);

#include <unistd.h>
dup, dup2, dup3 - дублира файлов дескриптор


Системното извикване dup() разпределя нов файлов дескриптор, който препраща към същото описание на отворен файл като дескриптора oldfd.
Гарантирано е, че новият номер на файловия дескриптор е файловият дескриптор с най-нисък номер, който не е бил използван в процеса на извикване.

След успешно връщане старият и новият файлови дескриптори могат да се използват взаимозаменяемо. 
Тъй като двата файлови дескриптора се отнасят до едно и също отворено описание на файл, те споделят файлово отместване и флагове за състояние на файл; 
например, ако отместването на файла е модифицирано чрез lseek(2) на един от файловите дескриптори, отместването също се променя за другия файлов дескриптор.
       
Двата файлови дескриптора не споделят флагове за файлов дескриптор (флаг за затваряне при изпълнение).

RETURN VALUE
При успех връща нов файлов дескриптор
При грешка -1



dup2(2) 
int dup2(int oldfd, int newfd);


dup2()
Системното извикване dup2() изпълнява същата задача като dup(), но вместо да използва неизползвания файлов дескриптор с най-нисък номер, 
той използва номера на файловия дескриптор, указан в newfd. 
С други думи, файловият дескриптор newfd е коригиран така, че сега да препраща към същото описание на отворен файл като oldfd.

Ако файловият дескриптор newfd е бил отворен преди това, той се затваря, преди да бъде използван повторно
