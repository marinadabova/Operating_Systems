=>Архивиране и компресиране
	-Архивиране --обединяване на много файлове в един архив
		    --tar, cpio
	-Компресиране--взимане на файл и го променяме, така че размера му става по-малък
		     --xz, compress, gzip, bzip2, lzma
tar -архивиране,
    -файловете са във формат ".tar"
    -създава, extract-ва, list-ва архиви

tar cfv <име на архив> <изброява файловете> -правим архив; 
c=create, f-да изброим, v=verbose- да видим какво се случва

tar tfv <име на архив> 			- листваме какво има в архива
tar xfv <име на архив> 			- extract-ваме архива
tar xfv <име на архив> -C <име на dir> 	- избираме в коя директория да extract-нем 


xz -копресираме
   -намаляване размера на файла
   -файловете са във формат ".xz"

xz -z <име на архив> 	-копресираме
xz –d <име на архив> 	-декомпресираме
unxz <име на архив> 	-декомпресираме

tar cfvJ <име на новия file > <подавам files> -архивираме и веднага компресираме; той няма окончание .xz

=>File(stream) redirection:
fd=файлов дескриптор- едно число, идентифициращо отворен файл

0 stdin   <- keyboard  	< от файл
1 stdout  -> terminal	> към файл
2 stderr  -> terminal 	> към файл

	=STDIN
 <
от файл може да го вземем
пример: sort < /etc/passwd

	=STDOUT
 >
може да го пренасочим към файл(само него)
пример: find /proc | -type d > find_stdout.txt

stdout-a е във файла
stderr-a е на терминала

!------------!
> overwrite-ва
>> append-ва
!------------!

Echo -принтира линийка
Echo > -ще се презапише в същия файл
Echo >> -append-ваме 

примери:
1) echo "Hello" > hello_stdout.txt
като cat-нем, ще видим Hello

echo "asdf" > hello_stdout.txt
като cat-нем, ще видим asdf

!това е overwrite

2) echo "hello" >> hello_stdout.txt
като cat-нем, ще видим asdf
		       hello
!това е append


echo "Hello" >> hello.txt --> файлът Не е нужно да е създаден


	=STDERR

2>
пренасочваме stderr-а
в терминала остава stdout-a

пример: find /proc | -type d 2> find_stderr.txt

!----------------------------------!
2>> append-ваме
&> пренасочваме stdout-a и stderr-а
!----------------------------------!

< stdin form a file
>  stdout to a file(overwrite)
>>  stdout to a file(append)
2> stderr to a file(overwrite)
2>> stderr to a file (append)
&> both stdout and stderr


!!!!!!! /dev/null = бездна, кошче -> ако пренасочим натам, всичко изчезва !!!

find /proc | -type d > <output -name of file>  2>&1
							-Казваме
								1)stdout -> output
								  stderr -> terminal
								2)чрез  2>&1 	stdout -> output
										stderr -> output
							Искаме stderr да сочи към мястото, където сочи stdout 

find /proc | -type d 2>&1 <output -name of file>  	-Казваме stdout -> output
							   	 stderr -> terminal

ls -laR /proc |2> /dev/null 				-За да няма stderr на output-a

 
=>Piping(Комбинация с команди)
Бележи се с "|"
Примера 2 аргумента -един от ляво на | и един отдясно

foo | bar -> stdout на foo, отива като stdin на bar

pipeline =последователност от много pipe-ове

Cat <name file> |wc -l -колко реда има в даден файл

=>Combining files and merging text

cat -конкатенира файлове

paste -merge-ва файлове(text files)

paste <file1> <file2> 		-по default е tab разстояние
paste -d '@' <file1> <file2> 	-разстоянието ние го задаваме, в случая е @
paste -d '@' -s <file1><file2> 	-първо показва съдържанието на файл1 с разстояние между текста/думите @ и след това показва съдържанието на файл2

wc

wc -c <name> -брои байтове
wc -m <name> -брои символи
wc -l <name> -броя на редовете
wc -w <name> -броя на думите

cut  -разделя структуриран input на секции

cut -c 1-3  		-от 1 до 3 символа на всеки ред
cut -d ':' -f 6  	-дефинираме делимитър и листваме колонката-в случая е 6
cut -d ':' -f 1,6 	–дефинираме делимитър и листваме 1 и 6та колона
cut -d ':' -f 2,3-5 

tr  = translate -  превръща едно множество от символи в друго множество от символи

cat <name file> | tr a o  	-а-тата да станат о-та
cat <name file> | tr -s a  	-смачква символите до 1 (аааа->a)
cat <name file> | tr -d o  	-трием символи – о в случая
cat <name file> | tr a-z A-Z 	-мачва всички малки символи и ги прави на големи букви
!!ИЗПОЛЗВА СЕ ВИНАГИ ЧРЕЗ PIPE!!

grep -изкарва, търси шаблон

cat <name file> | grep "this" 			-мачва думата в " "
cat <name file> | grep --color "this"  		-да оцвети мач-а
cat <name file> | grep --color  -n "this"  	-да оцвети мач-а и показва на кой ред
cat <name file> | grep --color  -i "this" 	-да оцвети мач-а и мачва всички без значение малки или големи букви
cat <name file> | grep --color  -v "this" 	-да оцвети мач-а и показва редовете които не мачват
cat <name file> | grep --color  -w "is"  	-да оцвети мач-а и мачва където е отделена с white space
cat <name file> | grep --color  -A 1  		-да оцвети мач-а и показва реда  мач и 1ред след мач-а
cat <name file> | grep --color  -B 2  		-да оцвети мач-а и показва 2 реда над мача
cat <name file> | grep --color  -C 2   		-да оцвети мач-а и показва 2 реда отгоре и отдолу на мач-а 


sed -едитор на потоци

sed ‘s/unix/linux/2’ <name file> 
     ‘1…/2.../3.../4’ =израз
1.	операция, която искам да извърша
2.	стринг, който мачва
3.	с какво да заместим 2част
4.	може число-> (в случая 	2 значи за 2ро срещане заместваме)
	g за всяко да заместваме
	празно- за първо срещане да го заместим
	2g от 2рото до края да заместим

awk -взима файл, минава през всеки ред на файла
|awk '{print $1}' 			-принти 1 колона
             $2      			-2колона
             $0      			-всички колони
|awk -F ':' '{print $1}' 		-за делимитър
|awk '$1!=5 {print $0}' 		-първата колона да е различна от 5
|awk '$2 ~ "sd" {print $0}'  		-да е подобно на стринга, който сме подали
|awk '{sum +=$1} END {print sum}'  	-да изпринтим сумата на 1 колона

sort – сортираме, по default сортира лексикографски(по азбучен ред)

sort -n <name>  	-сортиране на числа
sort -nr <name> 	-сортира от НГ>НМ
|sort -t ':' -k 3 -n  	-сортиране по колонка
       				-t –показва делимитър
                 			-k –избираме колона
sort + cut -d ‘:’ -f 3

uniq- примахва еднаквите линии, редове от някакъв сортиран текст
!!ИЗПОЛЗВА СЕ СЪС СОРТИРАНЕ!!

cat <name file> |sort | uniq
cat <name file> |sort | uniq -c 				-показва колко пъти се е срещала дадена дума
cat <name file> |sort | uniq -c | sort -k 1 -n  		-показва колко пъти се е срещала дадена дума и сортираме 1 колона
cat <name file> |sort | uniq -c | sort -k 1 -n | tail -n 1 	-показва колко пъти се е срещала дадена дума и взимаме последния ред
cat <name file> |sort | uniq -c | sort -k 1 -n | head -1 	-показва колко пъти се е срещала дадена дума и взимаме първия ред
