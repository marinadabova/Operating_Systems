#Зад. 34 2019-SE-02 Напишете шел скрипт, който приема множество параметри. Общ вид на извикване: ./foo.sh [-n N] FILE1...
#В общия случай параметрите се третират като имена на (.log) файлове, които трябва да бъдат обработени от скрипта, със следното изключение:
#ако първият параметър е стрингът -n, то вторият параметър е число, дефиниращо стойност на променливата N, която ще ползваме в скрипта.
#Въвеждаме понятието идентификатор на файл (ИДФ), което се състои от името на даден файл без разширението .log. За удобство приемаме, че скриптът:
#• ще бъде извикван с аргументи имена на файлове, винаги завършващи на .log
#• няма да бъде извикван с аргументи имена на файлове с еднакъв ИДФ.
#Лог файловете са текстови, като всеки ред има следния формат:
#• време: timestamp във формат YYYY-MM-DD HH:MM:SS
#• интервал
#• данни: поредица от символи с произволна дължина
#За удобство приемаме, че редовете във всеки файл са сортирани по време възходящо.
#Примерно съдържание на даден лог файл:
#2019-05-05 06:26:54 orthanc rsyslogd: rsyslogd was HUPed
#2019-05-06 06:30:32 orthanc rsyslogd: rsyslogd was HUPed
#2019-05-06 10:48:29 orthanc kernel: [1725379.728871] Chrome_~dThread[876]: segfault
#Скриптът трябва да извежда на STDOUT последните N реда (ако N не е дефинирано - 10 реда) от всеки файл, в следния формат:
#• timestamp във формат YYYY-MM-DD HH:MM:SS
#• интервал
#• ИДФ
#• интервал
#• данни
#Изходът трябва да бъде глобално сортиран по време възходящо

#!/bin/bash

stdout=$(mktemp)

if [[ ! "$1" =~ ^-n$ ]]; then
        N=10
else
        if [[ "$2" =~ ^[0-9]+$ ]]; then
                N=$2
        else
                echo "N is not valid argument"
                exit 1
        fi
fi

for file in "$@"; do
        if [[ -f $file ]]; then
                IDF=$(basename -s .log $file ) #  the same as basename $file .log
                cat $file | tail -$N| sed -E 's/(^[0-9]{4}-[0-9]{2}-[0-9]{2}[[:space:]]+[0-9]{2}:[0-9]{2}:[0-9]{2})(.+)/\1 $IDF \2/g' >> $stdout
        fi

done

cat $stdout |sort -n -t ' ' -k1,2
rm -- $stdout
