
#Зад. 43 2021-SE-02 Един от често използваните DNS сървъри е BIND9, при който описанието на DNS зоните обикновенно стои в текстови файлове, наричани зонални файлове.
#За улеснение, в рамките на задачата, ще ползваме опростено описание на зоналните файлове.
#Под whitespace разбираме произволна комбинация от табове и интервали.
#Под FQDN разбираме низ, който има допустими символи малки латински букви, цифри и точка; не може да започва с точка, не може да има две или повече съседни точки,
#задължително завършва с точка.
#Зоналните файлове съдържат ресурсни записи, по един на ред. Общият вид на даден ресурсен запис e <ключ> <TTL> <клас> <тип> <RDATA>, разделени с whitespace, например:
#astero.openfmi.net. 3600 IN A 185.117.82.99
#Където:
#• ключ (astero.openfmi.net.) – FQDN
#• TTL (3600) – цифри; полето може да липсва
#• клас (IN) - главни латински букви; класът винаги е IN
#• тип (A) - главни латински букви; някое от SOA, NS, A, AAAA
#• RDATA (185.117.82.99) - данни на записа; различни за различните типове ресурсни записи; всичко след типа до края на реда.
#Знакът точка-и-запетая ; е знак за коментар, и всичко след него до края на реда се игнорира.
#Във всеки зонален файл трябва да има точно един SOA запис, и той трябва да е първият запис във файла. Пример за едноредов SOA запис:
#openfmi.net. 3600 IN SOA nimbus.fccf.net. root.fccf.net. 2021041901 86400 7200 3024000 3600
#RDATA-та на SOA запис се състои от два FQDN-а и пет числа, разделени с whitespace.
#Въпреки, че горното е валиден SOA запис, за прегледност в зоналните файлове често се ползва следният синтаксис (многоредов SOA запис, еквивалентен на горния):
#openfmi.net. 3600 IN SOA nimbus.fccf.net. root.fccf.net. (
#2021041901 ; serial
#86400 ; refresh
#7200 ; retry
#3024000 ; expire
#3600 ; negative TTL
#)
#т.е., поредицата от числа се разбива на няколко реда, оградени в обикновенни скоби, и за всяко число се слага коментар какво означава.
#Първото от тези числа (serial) представлява серийният номер на зоната, който трябва да се увеличава всеки път,
#когато нещо в зоналният файл се промени. Изключително важно е това число само да нараства, и никога да не намалява.
#Един от често използваните формати за сериен номер, който показва кога е настъпила последната промяна в зоналния файл представлява число във вида YYYYMMDDTT,
#т.е., четири цифри за година, две цифри за месец, две цифри за дата и още две цифри за поредна промяна в рамките на описания ден.
#За последните две цифри (ТТ) има ограничение да са от 00 до 99 (естествено, така не може да има повече от 100 промени в рамките на един ден).
#За удобство приемаме, че конкретен сериен номер (точната поредица цифри) се среща само на едно място в зоналния файл.
#Напишете шел скрипт, който по подадени имена на зонални файлове променя серийният номер в SOA записа на всеки файл по следният алгоритъм:
#• ако датата в серийният номер е по-стара от днешната, новият сериен номер трябва да е от вида днешнадата00
#• ако датата в серийният номер е равна на днешната, серийният номер трябва да се увеличи с единица
#Важат следните условия:
#• скриптът трябва да може да обработва и едноредови, и многоредови SOA записи
#• за всеки зонален файл, който не е успял да обработи, скриптът трябва да вади съобщение за грешка, което включва и името на зоналния файл.
#Съобщенията трябва да са лесно обработваеми с познатите инструменти за обработка на текст.

#!/bin/bash

for file in "$@"; do
        if [[ ! -f $file ]]; then
                echo "$file is not a file"
                exit 1
        fi
        first_line=$(head -1 $file)
        #echo $first_line
        if ( echo "$first_line" | grep -qv "SOA") ; then
                echo "There is no SOA record in $file"
                continue
        elif (echo "$first_line"| egrep -q "^([a-z0-9]+\.)+(\s+[0-9]+)?\s+IN\s+SOA\s+\1\s+\1[0-9]{10}(\s+[0-9]+){4}\s+\($" ); then
                serialPrev=$(cat $file| head -2| tail -1| awk -F ';' '{print $1}')
                date=$(echo $serialPrev| cut -c -8)
                cur_date=$(date +"%Y%m%d")
                if [[ $date -lt $cur_date ]]; then
                serial="${cur_date}"00
        elif [[ $date -eq $cur_date ]]; then
            serial=$(echo "$serialPrev + 1" |bc)
        fi
        #sed -i -E "s/(^[[:space:]]*)$serialPrev(*\;\.+$)/\1$serial\2/g" $file
                sed -E -i "s/(^[[:space:]]*)$serialPrev([[:space:]]*;.+$)/\1$serial\2/g" $file

#elif (echo "$first_line"| egrep -q "^([a-z0-9]+\.)+(\s+[0-9]+)?\s+IN\s+SOA\s+\1\s+\1[0-9]{10}(\s+[0-9]+){4}" ); then
        else
                serialPrev=$(echo "$first_line" | sed -E 's/^(.*\.)(\s+)([0-9]*)(\s[0-9]+)/\3/g')
                date=$(echo $serialPrev| cut -c -8)
                cur_date=$(date +"%Y%m%d")

                if [[ $date -lt $cur_date ]]; then
                        serial="${cur_date}"00
                elif [[ $date -eq $cur_date ]]; then
                        serial=$(echo "$serialPrev + 1" |bc)
                fi

                sed -E -i "s/^(.*\.)(\s+)([0-9]*)(\s[0-9]+/\1\2$serial\4/g" $file
                #       sed -i "s/$serialPrev/$serial/" $file

        #elif echo "$first_line" | egrep -q "^([a-z0-9]+\.)+\s([0-9]+\s)?IN\sSOA(\s([a-z0-9]+\.)+){2}\s\("; then
fi

done
